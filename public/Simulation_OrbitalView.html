<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Psyche Simulation - Asteroid</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #container { width: 100vw; height: 100vh; }
    #switch {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background-color: #DB371F;
      color: #f3f3f4;
      border: none;
      border-radius: 5px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s, transform 0.2s;
    }
    button:hover {
      background-color: #9d2715;
      transform: scale(1.05);
    }
    button:active {
      transform: scale(1);
    }
  </style>
</head>
<body>
<div id="container"></div>
<div id="switch">
  <button onclick="window.location.href='Simulation_TerrestrialView.html'">Switch to Terrestrial View</button>
</div>

<!-- Import Three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", () => {
  // Previous code for reference for those working in orbital view
  //   // Initialize scene, camera, and renderer
  //   const scene = new THREE.Scene();
  //   const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  //   const renderer = new THREE.WebGLRenderer({ antialias: true });
  //   renderer.setSize(window.innerWidth, window.innerHeight);
  //   document.getElementById('container').appendChild(renderer.domElement);

  //   // Create asteroid geometry
  //   const geometry = new THREE.SphereBufferGeometry(1, 64, 64);
    
  //   // Create Star Geometry
  //   const star_geometry = new THREE.SphereBufferGeometry(3,256,256)
    
  //   // Add random displacement for craters
  //   const positions = geometry.attributes.position.array;
  //   for (let i = 0; i < positions.length; i += 3) {
  //     const offset = (Math.random() - 0.5) * 0.1;
  //     positions[i] += offset;     // X coordinate
  //     positions[i + 1] += offset; // Y coordinate
  //     positions[i + 2] += offset; // Z coordinate
  //   }
  //   geometry.attributes.position.needsUpdate = true;

  //   // Create material for the asteroid
  //   const material = new THREE.MeshStandardMaterial({
  //     color: 0x808080,
  //     roughness: 0.9,
  //     metalness: 0.1,
  //   });

  //   // Create Material for the Star
  //   const star_material = new THREE.MeshStandardMaterial({
  //     color: 0xFCE5CD,
  //     roughness: 0.1,
  //     metalness: 0.5,
  //   });


  //   // Create star and asteroid mesh
  //   const asteroid = new THREE.Mesh(geometry, material);
  //   const star = new THREE.Mesh(star_geometry,material)
  //   scene.add(asteroid);
  //   star.position.set(512,512,512)
  //   scene.add(star)

    

  //   // Add lights
  //   const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
  //   scene.add(ambientLight);
  //   const pointLight = new THREE.PointLight(0xffffff, 1.2);
  //   pointLight.position.set(25, 25, 25);
  //   scene.add(pointLight);

  //   //set camera center
  //   camera.position.z = 3;

  //   // Star field
  //   const starGeometry = new THREE.BufferGeometry();
  //   const starCount = 5000;
  //   const starVertices = [];
  //   const time = 1;
  //   const day_x = 0.0005;
  //   const day_y = 0.001;

  //   for (let i = 0; i < starCount; i++) {
  //     const x = (Math.random() - 0.5) * 400;
  //     const y = (Math.random() - 0.5) * 400;
  //     const z = (Math.random() - 0.5) * 400;
  //     starVertices.push(x, y, z);
  //   }
  //   starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
  //   const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
  //   const stars = new THREE.Points(starGeometry, starMaterial);
  //   scene.add(stars);
    
  // //controls to zoom in and stuff
  //   const controls = new THREE.OrbitControls(camera, renderer.domElement);
  //   controls.enableDamping = true;
  //   controls.dampingFactor = 0.05;
  //   controls.enableZoom = true;
  //   controls.autoRotate = false;
  //   controls.enablePan = false;

  //   //limit how zoomed out and zoomed in terrestrial view can be
  //   controls.minDistance = 2; 
  //   controls.maxDistance = 20; 

    //start of code for insert new asteroid

    //add scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    //ambient light
    const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1.5);
    pointLight.position.set(-10, 10, 5);
    scene.add(pointLight);

    //set camera center
    camera.position.z = 3;

    //camera controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.autoRotate = false;
    controls.enablePan = false;

    //limit how zoomed out and zoomed in orbital view can be
    controls.minDistance = 2; 
    controls.maxDistance = 20;

    // Load the asteroid asynchronously using GLTFLoader
    const loader = new THREE.GLTFLoader();
    let asteroid = null;

    // Create a parent group to add the asteroid to, for easier centering
    const asteroidGroup = new THREE.Group();
    scene.add(asteroidGroup);


    loader.load(
        './psycheModelCentered.glb',  
        (gltf) => {
          asteroid = gltf.scene;

          // Adjust material to be a darker gray and respond to lighting
          asteroid.traverse((child) => {
            if (child.isMesh) {
              child.material = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.8, metalness: 0.3 });
            }
          });

          // Compute the bounding box to center the asteroid
          const box = new THREE.Box3().setFromObject(asteroid);
          const center = box.getCenter(new THREE.Vector3());
          asteroid.position.sub(center);  // Offset the asteroid to center it at (0, 0, 0)

          // Add the asteroid to the parent group
          asteroidGroup.add(asteroid);

          // Set the OrbitControls target to the asteroid's group center
          controls.target.set(0, 0, 0);
          controls.update();
          
        },
      
      );
    
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 5000;
      const starVertices = [];
      const time = 1;
      const day_x = 0.0005;
      const day_y = 0.001;

      for (let i = 0; i < starCount; i++) {
        const x = (Math.random() - 0.5) * 400;
        const y = (Math.random() - 0.5) * 400;
        const z = (Math.random() - 0.5) * 400;
        starVertices.push(x, y, z);
      }
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
  

    //end of insert new asteroid

    //adding the sun
    const sunGeometry = new THREE.SphereBufferGeometry(10, 64, 64);
    const sunMaterial = new THREE.MeshBasicMaterial({
      color: 0xD14009,
      emissive: 0xD14009,
      emissiveIntensity: 2
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.position.set(-70, 0, -30);
    scene.add(sun);

    //glowing halo around the sun
    const haloRadius = 11;
    const haloGeometry = new THREE.SphereBufferGeometry(haloRadius, 64, 64);
    const haloMaterial = new THREE.MeshBasicMaterial({
      color: 0xB90C05,
      emissive: 0xB90C05,
      emissiveIntensity: 0.9,
      transparent: true,
      opacity: 0.1,
    });
    const halo = new THREE.Mesh(haloGeometry, haloMaterial);
    halo.position.set(-70, 0, -30); // Position the halo around the sun
    scene.add(halo);

    

    // Animation loop for asteroid rotation
    // TODO: 
      // Ensure rotation lines up with orbit/time correctly. Allowing us to rotate at a specific speed determined by time (which will later be manipulated by a slider/speedup UI element).
      // Add "Orbital Path" variable/function that has a way for sliding the "asteroid" mesh in a circle around the star. The amount of distance moved along the arc each time the function is run should be a variable (for Mel to bind with time.)
    // function animate() {
    //   requestAnimationFrame(animate);

    //   // Update controls for smoothness
    //   asteroid.rotation.x += day_x * time;
    //   asteroid.rotation.y += day_y * time;
      
    //   controls.update();

    //   // Render the scene
    //   renderer.render(scene, camera);
    // }
    // animate();
    function animate() {
      requestAnimationFrame(animate);

      // Ensure the asteroid exists before rotating it
      if (asteroid) {
        asteroid.rotation.x += day_x * time;
        asteroid.rotation.y += day_y * time;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate();


    // Handle window resizing
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  });
  
</script>
</body>
</html>
