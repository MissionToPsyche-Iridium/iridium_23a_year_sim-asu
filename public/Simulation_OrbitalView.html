<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Psyche Simulation - Asteroid</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #container { width: 100vw; height: 100vh; }

    #fullscreen-btn {
        position: absolute;
        bottom: 10px;
        right: 10px;
        z-index: 10;
        background: #DB371F;
        color: #f3f3f4;
        border: none;
        border-radius: 5px;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s;
    }
    #fullscreen-btn:hover {
        background-color: #9d2715;
        transform: scale(1.1);
    }

    #fullscreen-btn:active {
        transform: scale(0.95);
    }
    #date-display {
      position: absolute;
      font-family: 'Lato', monospace;
      top: 10px;
      left: 50%;
      text-align: center;
      background: rgba(0, 0, 0, 0.5);
      transform: translateX(-50%);
      font-size: 24px;
      color: white;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="date-display"></div>

<div id="container"></div>
<button id="fullscreen-btn" title="Toggle Fullscreen">
  <svg id="fullscreen-icon" width="24" height="24" viewBox="0 0 24 24" fill="none">
    <path d="M4 4h6v2H6v4H4V4zm10 0h6v6h-2V6h-4V4zM4 14h2v4h4v2H4v-6zm14 0h2v6h-6v-2h4v-4z" 
          fill="white"/>
  </svg>
</button>
  
<!-- Import Three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", () => {

      // Date and time display function
      function updateDateTime() {
      const dateDisplay = document.getElementById('date-display');
      const now = new Date();

      const day = String(now.getDate()).padStart(2, '0');
      const month = now.toLocaleString('default', { month: 'long' }).toUpperCase();
      const year = now.getFullYear();
      
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');

      dateDisplay.innerHTML = `${day} ${month} ${year}<br>${hours}:${minutes}:${seconds}`;
    }

    // Update the date and time every second
    updateDateTime();
    setInterval(updateDateTime, 1000);

    // Add scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    // Fullscreen functionality
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const fullscreenIcon = document.getElementById('fullscreen-icon').querySelector('path');

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => {
                fullscreenIcon.setAttribute('d', 'M6 6h12v12H6z');  // Fullscreen icon
            }).catch(err => {
                console.error('Error attempting to enable fullscreen:', err);
            });
        } else {
            document.exitFullscreen().then(() => {
                fullscreenIcon.setAttribute('d', 'M4 4h6v2H6v4H4V4zm10 0h6v6h-2V6h-4V4zM4 14h2v4h4v2H4v-6zm14 0h2v6h-6v-2h4v-4z');  // Exit fullscreen icon
            }).catch(err => {
                console.error('Error attempting to exit fullscreen:', err);
            });
        }
    }

    fullscreenBtn.addEventListener('click', toggleFullscreen);

    document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement) {
            fullscreenIcon.setAttribute('d', 'M4 4h6v2H6v4H4V4zm10 0h6v6h-2V6h-4V4zM4 14h2v4h4v2H4v-6zm14 0h2v6h-6v-2h4v-4z');
        } else {
            fullscreenIcon.setAttribute('d', 'M6 6h12v12H6z');
        }
    });


    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1.5);
    pointLight.position.set(-10, 10, 5);
    scene.add(pointLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.1);
    directionalLight.position.set(-330, 0, 0);
    scene.add(directionalLight);

    // Set camera center
    camera.position.z = 0;

    // Camera controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = false;

    // Limit how zoomed out and zoomed in orbital view can be
    controls.minDistance = 10;
    controls.maxDistance = 2000;

    // Load the asteroid asynchronously using GLTFLoader
    const loader = new THREE.GLTFLoader();
    let asteroid = null;

    // Create a parent group to add the asteroid to, for easier centering
    const asteroidGroup = new THREE.Group();
    scene.add(asteroidGroup);

    loader.load(
      './psycheModelCentered.glb',
      (gltf) => {
        asteroid = gltf.scene;

        // Adjust material to be a darker gray and respond to lighting
        asteroid.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.8, metalness: 0.3 });
          }
        });

        // Compute the bounding box to center the asteroid
        const box = new THREE.Box3().setFromObject(asteroid);
        const center = box.getCenter(new THREE.Vector3());
        asteroid.position.sub(center);  // Offset the asteroid to center it at (0, 0, 0)

        // Add the asteroid to the parent group
        asteroidGroup.add(asteroid);

        // Set the OrbitControls target to the asteroid's group center
        controls.target.set(0, 0, 0);
        controls.update();
      },
      undefined,
      (error) => {
        console.error('Error loading asteroid model:', error);
      }
    );

    // Star field
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 5000;
    const starVertices = [];
    const time = 1;
    const day_x = 0.0005;
    const day_y = 0.001;

    for (let i = 0; i < starCount; i++) {
      const x = (Math.random() - 0.5) * 5000;
      const y = (Math.random() - 0.5) * 5000;
      const z = (Math.random() - 0.5) * 5000;
      starVertices.push(x, y, z);
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Adding the sun using GLB model
    const loader2 = new THREE.GLTFLoader();

    let sunModel = null;
    loader2.load(
      './sun.glb',
      (gltf) => {
        sunModel = gltf.scene;

        console.log('Sun model loaded:', sunModel);

        sunModel.position.set(-330, 0, 0);
        sunModel.scale.set(0.155, 0.155, 0.155); //measured by psyche diameter divided by sun diameter, sun is 6194 times larger than psyche

        scene.add(sunModel);
      },
      undefined,
      (error) => {
        console.error('Error loading sun model:', error);
      }
    );

    // Create the orbital path
    const createOrbitalPath = (radius, color = 0xffffff) => {
      const orbitGeometry = new THREE.RingGeometry(radius - 0.1, radius + 0.1, 1024);
      const orbitMaterial = new THREE.MeshBasicMaterial({
        color: color,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.2,
      });

      const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
      orbit.rotation.x = Math.PI / 2;
      return orbit;
    };

    // Add the orbital path to the scene
    const orbitRadius = 352.5;
    const orbitDays = 1830;
    const orbitPath = createOrbitalPath(orbitRadius, 0xffffff);
    orbitPath.position.set(-290, 0, 0); // Match the sun's position
    scene.add(orbitPath);

    let followAsteroid = true;

    function updateLighting() {
      if (!asteroid || !sunModel) return;

      const sunPos = sunModel.position.clone();
      const asteroidPos = asteroid.position.clone();

      const lightDirection = new THREE.Vector3().subVectors(sunPos, asteroidPos).normalize();
      directionalLight.position.copy(lightDirection.multiplyScalar(orbitRadius * 1.2));
    }

    // Calculate the asteroid's starting position based on a date

    // my plan here is to split up the orbit into 1830 segments (it takes 1830 days to do a full orbit)
    // ive yet to determine where and when the orbit actually starts and ends, and that will be an easy fix for when i *do* determine it
    // as i can just change the startDate value
    //
    // but what's happening here is that i'm taking Jan 1 2020 as a reference date for when the orbit began
    // since the value of current day will always be greater than the start date, it is easy to compute at which point of the orbit the
    // asteroid is currently at using the math below
    //
    // the difference between today and the startDate is divided by the number of milliseconds in a day
    // since the value of today - startDate is in milliseconds, dividing it by (1000 * 60 * 60 * 24) gives us the actual number of days
    //
    // actual num of days is then modulo'd by 1830 to find which day of the orbit we're in, and then the day/total days
    // is mapped to a point in the orbit

    function getInitialPosition() {
      const startDate = new Date(2020, 0, 1); // random reference date
      const today = new Date();
      const daysElapsed = Math.floor((today - startDate) / (1000 * 60 * 60 * 24)); // days since reference date
      const orbitSegment = daysElapsed % orbitDays; // get remainder within the 1830-day cycle
      return (orbitSegment / orbitDays) * (Math.PI * 2); // convert to radians (full circle = 2Ï€)
      }

    let initialPosition = getInitialPosition();

    function getInitialAngle() {
      const startDate = new Date(2020, 0, 1); // reference date
      const now = new Date();
      const msElapsed = now - startDate;

      const hoursElapsed = msElapsed / (1000 * 60 * 60);
      const rotationsElapsed = hoursElapsed / 4.2;
      const initialAngle = (rotationsElapsed % 1) * (Math.PI * 2); // map to 0 - 2pi range

      return initialAngle;
    }

    function animate() {
      requestAnimationFrame(animate);

      if (asteroid) {

        // the math is a little arbitrary
        // psyche is 2.5 to 3.3 astronomical units away from the sun so i set the radius of the orbit as 351 
        // (the sun is 61*61*61, and the average distance between the farthest and nearest points of psyche's distance from the sun is 290 (330+250/2))
        // 
        // the sun's position is set to -330, so it's not completely centered in the orbit radius
        // this makes the furthest point between the sun and psyche 3.3 AUs, and the closest point 2.5 AUs, and the sun in between
        // ensures the distance is accurate as its size is accounted for

        // and then i just calculated the circumference of the orbit itself as 2pi * 290 and then the orbital speed as just the
        // circumference / the number of days it takes to orbit

        const orbitalSpeed = 0.0000001923; // ACTUAL speed, keeping it at 0.01 for testing only
        //const orbitalSpeed = 0.1;
        const elapsedTime = performance.now() * 0.001; // Convert ms to seconds
        const dynamicAngle = initialPosition + elapsedTime * orbitalSpeed;

        asteroid.position.x = -290 + orbitRadius * Math.cos(-dynamicAngle);
        asteroid.position.z = 0 + orbitRadius * Math.sin(-dynamicAngle);

        //asteroid.rotation.y = dynamicAngle;

        // accurate axis
        const psycheRotationSpeed = (Math.PI * 2) / (4.2 * 60 * 60);
        const deltaTime = performance.now() * -0.001;

        const initialAngle = getInitialAngle();
        asteroid.rotation.z = initialAngle + deltaTime * psycheRotationSpeed;

        controls.update();

        if (followAsteroid) {
          // Calculate the delta between the current target and asteroid's new position
          const previousTarget = controls.target.clone();
          const newTarget = asteroid.position.clone();
          const targetDelta = newTarget.clone().sub(previousTarget);

          // Move the camera by the same delta
          camera.position.add(targetDelta);

          // Update the control target to the asteroid
          controls.target.copy(newTarget);
        }

      }
      
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Handle window resizing
    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

  });
</script>
</body>
</html>